(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{170:function(e,v,t){"use strict";t.r(v);var _=t(0),a=Object(_.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"js重点基础知识记录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js重点基础知识记录","aria-hidden":"true"}},[e._v("#")]),e._v(" JS重点基础知识记录")]),e._v(" "),t("h2",{attrs:{id:"原始类型（primitive）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原始类型（primitive）","aria-hidden":"true"}},[e._v("#")]),e._v(" 原始类型（Primitive）")]),e._v(" "),t("p",[e._v("在 JS 中， 有6种原始类型值：")]),e._v(" "),t("ul",[t("li",[e._v("boolean")]),e._v(" "),t("li",[e._v("null")]),e._v(" "),t("li",[e._v("undefined")]),e._v(" "),t("li",[e._v("number")]),e._v(" "),t("li",[e._v("string")]),e._v(" "),t("li",[e._v("symbol")])]),e._v(" "),t("p",[e._v("原始类型存储的都是值， 是没有函数可以调用的， 比如不能这样： "),t("code",[e._v("null.toString()")]),e._v(";")]),e._v(" "),t("p",[e._v("可能会有"),t("code",[e._v("'1'.toString()")]),e._v("这样使用的，那是要因为 "),t("code",[e._v("1")]),e._v(" 已经转换成了 "),t("code",[e._v("String")]),e._v("类型，也就是对象类型。所以可以调用函数")]),e._v(" "),t("p",[e._v("JS 的"),t("code",[e._v("number")]),e._v(" 类型是浮点类型的，在使用中会遇到某些 Bug，比如 "),t("code",[e._v("0.1 + 0.2 !== 0.3")]),e._v("。"),t("code",[e._v("string")]),e._v("类型是不可变的，无论你在"),t("code",[e._v("string")]),e._v(" 类型上调用何种方法，都不会对值有改变。")]),e._v(" "),t("p",[e._v("另外对于"),t("code",[e._v("null")]),e._v(" 来说，很多人会认为他是个对象类型，其实这是错误的。虽然 "),t("code",[e._v("typeof null")]),e._v(" 会输出"),t("code",[e._v("object")]),e._v("，但是这只是 "),t("code",[e._v("JS")]),e._v(" 存在的一个悠久 "),t("code",[e._v("Bug")]),e._v("。在 "),t("code",[e._v("JS")]),e._v(" 的最初版本中使用的是 "),t("code",[e._v("32")]),e._v(" 位系统，为了性能考虑使用低位存储变量的类型信息，"),t("code",[e._v("000")]),e._v(" 开头代表是对象，然而 "),t("code",[e._v("null")]),e._v(" 表示为全零，所以将它错误的判断为 "),t("code",[e._v("object")]),e._v(" 。虽然现在的内部类型判断代码已经改变了，但是对于这个 "),t("code",[e._v("Bug")]),e._v(" 却是一直流传下来。")]),e._v(" "),t("h2",{attrs:{id:"对象类型-object"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象类型-object","aria-hidden":"true"}},[e._v("#")]),e._v(" 对象类型(Object)")]),e._v(" "),t("p",[e._v("在 "),t("code",[e._v("JS")]),e._v(" 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const a = []\n")])])]),t("p",[e._v("对于常量 "),t("code",[e._v("a")]),e._v(" 来说，假设内存地址（指针）为 "),t("code",[e._v("#001")]),e._v("，那么在地址 "),t("code",[e._v("#001")]),e._v(" 的位置存放了值 "),t("code",[e._v("[]")]),e._v("，常量 "),t("code",[e._v("a")]),e._v(" 存放了地址（指针） "),t("code",[e._v("#001")]),e._v("，再看以下代码")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const a = []\nconst b = a\nb.push(1)\n")])])]),t("p",[e._v("当我们将变量赋值给另外一个变量时，复制的是原本变量的地址（指针），也就是说当前变量 "),t("code",[e._v("b")]),e._v(" 存放的地址（指针）也是 "),t("code",[e._v("#001")]),e._v("，当我们进行数据修改的时候，就会修改存放在地址（指针） "),t("code",[e._v("#001")]),e._v(" 上的值，也就导致了两个变量的值都发生了改变。")]),e._v(" "),t("p",[e._v("接下来我们来看函数参数是对象的情况")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function test(person) {\n  person.age = 26\n  person = {\n    name: 'yyy',\n    age: 30\n  }\n\n  return person\n}\nconst p1 = {\n  name: 'yck',\n  age: 25\n}\nconst p2 = test(p1)\nconsole.log(p1) \t// -> ?\nconsole.log(p2) \t// -> ?\n")])])]),t("p",[e._v("对于以上代码，你是否能正确的写出结果呢？接下来让我为了解析一番：")]),e._v(" "),t("ul",[t("li",[e._v("首先，函数传参是传递对象指针的副本")]),e._v(" "),t("li",[e._v("到函数内部修改参数的属性这步，我相信大家都知道，当前 "),t("code",[e._v("p1")]),e._v(" 的值也被修改了")]),e._v(" "),t("li",[e._v("但是当我们重新为了 "),t("code",[e._v("person")]),e._v(" 分配了一个对象时就出现了分歧，请看下图")])]),e._v(" "),t("p",[t("img",{attrs:{src:"http://imgs.webxiaofan.com/15467573688503.jpg",alt:""}})]),e._v(" "),t("p",[e._v("所以最后 "),t("code",[e._v("person")]),e._v(" 拥有了一个新的地址（指针），也就和 "),t("code",[e._v("p1")]),e._v(" 没有任何关系了，导致了最终两个变量的值是不相同的。")]),e._v(" "),t("h2",{attrs:{id:"typeof-vs-instanceof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#typeof-vs-instanceof","aria-hidden":"true"}},[e._v("#")]),e._v(" typeof vs instanceof")]),e._v(" "),t("p",[t("code",[e._v("typeof")]),e._v(" 对于原始类型来说，除了 "),t("code",[e._v("null")]),e._v(" 都可以显示正确的类型")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("typeof 1 \t\t\t\t// 'number'\ntypeof '1' \t\t\t\t// 'string'\ntypeof undefined \t\t\t// 'undefined'\ntypeof true \t\t\t\t// 'boolean'\ntypeof Symbol() \t\t\t// 'symbol'\n")])])]),t("p",[t("code",[e._v("typeof")]),e._v(" 对于对象来说，除了函数都会显示 "),t("code",[e._v("object")]),e._v("，所以说 "),t("code",[e._v("typeof")]),e._v(" 并不能准确判断变量到底是什么类型")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("typeof [] // 'object'\ntypeof {} // 'object'\ntypeof console.log // 'function'\n")])])]),t("p",[e._v("如果我们想判断一个对象的正确类型，这时候可以考虑使用 "),t("code",[e._v("instanceof")]),e._v("，因为内部机制是通过原型链来判断的，在后面的章节中我们也会自己去实现一个 "),t("code",[e._v("instanceof")]),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const Person = function() {}\nconst p1 = new Person()\np1 instanceof Person \t\t// true\n\nvar str = 'hello world'\nstr instanceof String \t\t// false\n\nvar str1 = new String('hello world')\nstr1 instanceof String \t// true\n")])])]),t("p",[e._v("对于原始类型来说，你想直接通过 "),t("code",[e._v("instanceof")]),e._v(" 来判断类型是不行的，当然我们还是有办法让 "),t("code",[e._v("instanceof")]),e._v(" 判断原始类型的")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class PrimitiveString {\n  static [Symbol.hasInstance](x) {\n    return typeof x === 'string'\n  }\n}\nconsole.log('hello world' instanceof PrimitiveString) \t// true\n")])])]),t("p",[t("code",[e._v("Symbol.hasInstance")]),e._v(" 就是一个能让我们自定义 "),t("code",[e._v("instanceof")]),e._v(" 行为的东西，以上代码等同于 "),t("code",[e._v("typeof 'hello world' === 'string'")]),e._v("，所以结果自然是 "),t("code",[e._v("true")]),e._v(" 了。这其实也侧面反映了一个问题， "),t("code",[e._v("instanceof")]),e._v(" 也不是百分之百可信的。")]),e._v(" "),t("h2",{attrs:{id:"类型转换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类型转换","aria-hidden":"true"}},[e._v("#")]),e._v(" 类型转换")]),e._v(" "),t("p",[e._v("首先我们要知道，在 "),t("code",[e._v("JS")]),e._v(" 中类型转换只有三种情况，分别是：")]),e._v(" "),t("ul",[t("li",[e._v("转换为布尔值")]),e._v(" "),t("li",[e._v("转换为数字")]),e._v(" "),t("li",[e._v("转换为字符串")])]),e._v(" "),t("p",[e._v("我们先来看一个类型转换表格，然后再进入正题")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://imgs.webxiaofan.com/15467576662698.jpg",alt:""}})]),e._v(" "),t("h3",{attrs:{id:"转boolean"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#转boolean","aria-hidden":"true"}},[e._v("#")]),e._v(" 转Boolean")]),e._v(" "),t("p",[e._v("在条件判断时，除了 "),t("code",[e._v("undefined")]),e._v("， "),t("code",[e._v("null")]),e._v("， "),t("code",[e._v("false")]),e._v("， "),t("code",[e._v("NaN")]),e._v("， "),t("code",[e._v("''")]),e._v("， "),t("code",[e._v("0")]),e._v("， "),t("code",[e._v("-0")]),e._v("，其他所有值都转为 "),t("code",[e._v("true")]),e._v("，包括所有对象。")]),e._v(" "),t("h3",{attrs:{id:"对象转原始类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象转原始类型","aria-hidden":"true"}},[e._v("#")]),e._v(" 对象转原始类型")]),e._v(" "),t("p",[e._v("对象在转换类型的时候，会调用内置的 "),t("code",[e._v("[[ToPrimitive]]")]),e._v(" 函数，对于该函数来说，算法逻辑一般来说如下：")]),e._v(" "),t("ul",[t("li",[e._v("如果已经是原始类型了，那就不需要转换了")]),e._v(" "),t("li",[e._v("调用 "),t("code",[e._v("x.valueOf()")]),e._v("，如果转换为基础类型，就返回转换的值")]),e._v(" "),t("li",[e._v("调用 "),t("code",[e._v("x.toString()")]),e._v("，如果转换为基础类型，就返回转换的值")]),e._v(" "),t("li",[e._v("如果都没有返回原始类型，就会报错")])]),e._v(" "),t("p",[e._v("当然你也可以重写 "),t("code",[e._v("Symbol.toPrimitive")]),e._v(" ，该方法在转原始类型时调用优先级最高。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let a = {\n  valueOf() {\n    return 0\n  },\n  toString() {\n    return '1'\n  },\n  [Symbol.toPrimitive]() {\n    return 2\n  }\n}\n1 + a \t\t// => 3\n")])])]),t("h3",{attrs:{id:"四则运算符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四则运算符","aria-hidden":"true"}},[e._v("#")]),e._v(" 四则运算符")]),e._v(" "),t("p",[e._v("加法运算符不同于其他几个运算符，它有以下几个特点：")]),e._v(" "),t("ul",[t("li",[e._v("运算中其中一方为字符串，那么就会把另一方也转换为字符串")]),e._v(" "),t("li",[e._v("如果一方不是字符串或者数字，那么会将它转换为数字或者字符串")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1 + '1' \t\t// '11'\ntrue + true \t// 2\n4 + [1,2,3] \t// \"41,2,3\"\n")])])]),t("p",[e._v("如果你对于答案有疑问的话，请看解析：")]),e._v(" "),t("ul",[t("li",[e._v("对于第一行代码来说，触发特点一，所以将数字 "),t("code",[e._v("1")]),e._v(" 转换为字符串，得到结果 "),t("code",[e._v("'11'")])]),e._v(" "),t("li",[e._v("对于第二行代码来说，触发特点二，所以将 "),t("code",[e._v("true")]),e._v(" 转为数字 "),t("code",[e._v("1")])]),e._v(" "),t("li",[e._v("对于第三行代码来说，触发特点二，所以将数组通过 "),t("code",[e._v("toString")]),e._v(" 转为字符串 "),t("code",[e._v("1,2,3")]),e._v("，得到结果 "),t("code",[e._v("41,2,3")])])]),e._v(" "),t("p",[e._v("另外对于加法还需要注意这个表达式 "),t("code",[e._v("'a' + + 'b'")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'a' + + 'b' \t// -> \"aNaN\"\n")])])]),t("p",[e._v("因为 "),t("code",[e._v("+ 'b'")]),e._v(" 等于 "),t("code",[e._v("NaN")]),e._v("，所以结果为 "),t("code",[e._v('"aNaN"')]),e._v("，你可能也会在一些代码中看到过 "),t("code",[e._v("+ '1'")]),e._v(" 的形式来快速获取 "),t("code",[e._v("number")]),e._v(" 类型。")]),e._v(" "),t("p",[e._v("那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("4 * '3' // 12\n4 * [] // 0\n4 * [1, 2] // NaN\n")])])]),t("h3",{attrs:{id:"比较运算符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#比较运算符","aria-hidden":"true"}},[e._v("#")]),e._v(" 比较运算符")]),e._v(" "),t("ol",[t("li",[e._v("如果是对象，就通过 "),t("code",[e._v("toPrimitive")]),e._v(" 转换对象")]),e._v(" "),t("li",[e._v("如果是字符串，就通过 "),t("code",[e._v("unicode")]),e._v(" 字符索引来比较")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let a = {\n  valueOf() {\n    return 0\n  },\n  toString() {\n    return '1'\n  }\n}\na > -1 \t// true\n")])])]),t("p",[e._v("在以上代码中，因为 "),t("code",[e._v("a")]),e._v(" 是对象，所以会通过 "),t("code",[e._v("valueOf")]),e._v(" 转换为原始类型再比较值。")]),e._v(" "),t("h2",{attrs:{id:"this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this","aria-hidden":"true"}},[e._v("#")]),e._v(" this")]),e._v(" "),t("p",[t("code",[e._v("this")]),e._v(" 是很多人会混淆的概念，但是其实它一点都不难，只是网上很多文章把简单的东西说复杂了。")]),e._v(" "),t("p",[e._v("我们先来看几个函数调用的场景")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function foo() {\n  console.log(this.a)\n}\nvar a = 1\nfoo()\n\nconst obj = {\n  a: 2,\n  foo: foo\n}\nobj.foo()\n\nconst c = new foo()\n")])])]),t("p",[e._v("接下来我们一个个分析上面几个场景")]),e._v(" "),t("ul",[t("li",[e._v("对于直接调用 "),t("code",[e._v("foo")]),e._v(" 来说，不管 "),t("code",[e._v("foo")]),e._v(" 函数被放在了什么地方，"),t("code",[e._v("this")]),e._v(" 一定是 "),t("code",[e._v("window")])]),e._v(" "),t("li",[e._v("对于 "),t("code",[e._v("obj.foo()")]),e._v(" 来说，我们只需要记住，谁调用了函数，谁就是 "),t("code",[e._v("this")]),e._v("，所以在这个场景下 "),t("code",[e._v("foo")]),e._v(" 函数中的 "),t("code",[e._v("this")]),e._v(" 就是 "),t("code",[e._v("obj")]),e._v(" 对象")]),e._v(" "),t("li",[e._v("对于 "),t("code",[e._v("new")]),e._v(" 的方式来说，"),t("code",[e._v("this")]),e._v(" 被永远绑定在了 "),t("code",[e._v("c")]),e._v(" 上面，不会被任何方式改变 "),t("code",[e._v("this")])])]),e._v(" "),t("p",[e._v("说完了以上几种情况，其实很多代码中的 "),t("code",[e._v("this")]),e._v(" 应该就没什么问题了，下面让我们看看箭头函数中的 "),t("code",[e._v("this")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function a() {\n  return () => {\n    return () => {\n      console.log(this)\n    }\n  }\n}\nconsole.log(a()()())\n")])])]),t("p",[e._v("首先箭头函数其实是没有 "),t("code",[e._v("this")]),e._v(" 的，箭头函数中的 "),t("code",[e._v("this")]),e._v(" 只取决包裹箭头函数的第一个普通函数的 "),t("code",[e._v("this")]),e._v("。在这个例子中，因为包裹箭头函数的第一个普通函数是 "),t("code",[e._v("a")]),e._v("，所以此时的 "),t("code",[e._v("this")]),e._v(" 是 "),t("code",[e._v("window")]),e._v("。另外对箭头函数使用 "),t("code",[e._v("bind")]),e._v(" 这类函数是无效的。")]),e._v(" "),t("p",[e._v("最后种情况也就是 "),t("code",[e._v("bind")]),e._v(" 这些改变上下文的 "),t("code",[e._v("API")]),e._v(" 了，对于这些函数来说，"),t("code",[e._v("this")]),e._v(" 取决于第一个参数，如果第一个参数为空，那么就是 "),t("code",[e._v("window")]),e._v("。")]),e._v(" "),t("p",[e._v("如果对一个函数进行多次 "),t("code",[e._v("bind")]),e._v("，那么上下文会是什么呢？")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let a = {}\nlet fn = function () { console.log(this) }\nfn.bind().bind(a)() // => ?\n")])])]),t("p",[e._v("如果你认为输出结果是 "),t("code",[e._v("a")]),e._v("，那么你就错了，其实我们可以把上述代码转换成另一种形式")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// fn.bind().bind(a) 等于\nlet fn2 = function fn1() {\n  return function() {\n    return fn.apply()\n  }.apply(a)\n}\nfn2()\n")])])]),t("p",[e._v("可以从上述代码中发现，不管我们给函数 "),t("code",[e._v("bind")]),e._v(" 几次，"),t("code",[e._v("fn")]),e._v(" 中的 "),t("code",[e._v("this")]),e._v(" 永远由第一次 "),t("code",[e._v("bind")]),e._v(" 决定，所以结果永远是 "),t("code",[e._v("window")]),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let a = { name: 'yck' }\nfunction foo() {\n  console.log(this.name)\n}\nfoo.bind(a)() \t// => 'yck'\n")])])]),t("p",[e._v("以上就是 "),t("code",[e._v("this")]),e._v(" 的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 "),t("code",[e._v("this")]),e._v(" 最终指向哪里。")]),e._v(" "),t("p",[e._v("首先，"),t("code",[e._v("new")]),e._v(" 的方式优先级最高，接下来是 "),t("code",[e._v("bind")]),e._v(" 这些函数，然后是 "),t("code",[e._v("obj.foo()")]),e._v(" 这种调用方式，最后是 "),t("code",[e._v("foo")]),e._v(" 这种调用方式，同时，箭头函数的 "),t("code",[e._v("this")]),e._v(" 一旦被绑定，就不会再被任何方式所改变。")]),e._v(" "),t("p",[e._v("为更好理解,我们来看以下的这张流程图，图中的流程只针对于单个规则。")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://imgs.webxiaofan.com/15467584630250.jpg",alt:""}})]),e._v(" "),t("h2",{attrs:{id:"vs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vs","aria-hidden":"true"}},[e._v("#")]),e._v(" == vs ===")]),e._v(" "),t("p",[e._v("对于 "),t("code",[e._v("==")]),e._v(" 来说，如果对比双方的类型不一样的话，就会进行类型转换。")]),e._v(" "),t("p",[e._v("假如我们需要对比 "),t("code",[e._v("x")]),e._v(" 和 "),t("code",[e._v("y")]),e._v(" 是否相同，就会进行如下判断流程：")]),e._v(" "),t("p",[e._v("1.首先会判断两者类型是否相同。相同的话就是比大小了\n2.类型不相同的话，那么就会进行类型转换\n3.会先判断是否在对比 "),t("code",[e._v("null")]),e._v(" 和 "),t("code",[e._v("undefined")]),e._v("，是的话就会返回 "),t("code",[e._v("true")]),e._v("\n4.判断两者类型是否为 "),t("code",[e._v("string")]),e._v(" 和 "),t("code",[e._v("number")]),e._v("，是的话就会将字符串转换为 "),t("code",[e._v("number")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1 == '1'\n      ↓\n1 ==  1\n\n")])])]),t("p",[e._v("5.判断其中一方是否为 "),t("code",[e._v("boolean")]),e._v("，是的话就会把 "),t("code",[e._v("boolean")]),e._v(" 转为 "),t("code",[e._v("number")]),e._v(" 再进行判断")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("‘1’ == true\n        ↓\n‘1’ ==  1\n        ↓\n 1  ==  1\n")])])]),t("p",[e._v("6.判断其中一方是否为 "),t("code",[e._v("object")]),e._v(" 且另一方为 "),t("code",[e._v("string")]),e._v("、"),t("code",[e._v("number")]),e._v(" 或者 "),t("code",[e._v("symbol")]),e._v("，是的话就会把 "),t("code",[e._v("object")]),e._v(" 转为原始类型再进行判断")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("‘1’ == { name: ‘yck’ }\n        ↓\n‘1’ == ‘[object Object]’\n\n")])])]),t("p",[e._v("可参考流程图：\n"),t("img",{attrs:{src:"http://imgs.webxiaofan.com/15467590884353.jpg",alt:""}})]),e._v(" "),t("p",[e._v("当然了，这个流程图并没有将所有的情况都列举出来，我这里只将常用到的情况列举了，如果你想了解更多的内容可以参考 标准文档。")]),e._v(" "),t("p",[e._v("对于 "),t("code",[e._v("===")]),e._v(" 来说就简单多了，就是判断两者类型和值是否相同。")]),e._v(" "),t("h2",{attrs:{id:"闭包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包","aria-hidden":"true"}},[e._v("#")]),e._v(" 闭包")]),e._v(" "),t("p",[e._v("闭包的定义其实很简单：函数 "),t("code",[e._v("A")]),e._v(" 内部有一个函数 "),t("code",[e._v("B")]),e._v("，函数 "),t("code",[e._v("B")]),e._v(" 可以访问到函数 "),t("code",[e._v("A")]),e._v(" 中的变量，那么函数 "),t("code",[e._v("B")]),e._v(" 就是闭包。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function A() {\n  let a = 1\n  window.B = function () {\n      console.log(a)\n  }\n}\nA()\nB() // 1\n")])])]),t("p",[e._v("很多人对于闭包的解释可能是函数嵌套了函数，然后返回一个函数。其实这个解释是不完整的，就比如我上面这个例子就可以反驳这个观点。")]),e._v(" "),t("p",[e._v("在 "),t("code",[e._v("JS")]),e._v(" 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。")]),e._v(" "),t("blockquote",[t("p",[e._v("举例:循环中使用闭包解决 "),t("code",[e._v("var")]),e._v(" 定义函数的问题")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("for (var i = 1; i <= 5; i++) {\n  setTimeout(function timer() {\n    console.log(i)\n  }, i * 1000)\n}\n")])])]),t("p",[e._v("首先因为 "),t("code",[e._v("setTimeout")]),e._v(" 是个异步函数，所以会先把循环全部执行完毕，这时候 "),t("code",[e._v("i")]),e._v(" 就是 "),t("code",[e._v("6")]),e._v(" 了，所以会输出一堆 "),t("code",[e._v("6")]),e._v("。")]),e._v(" "),t("p",[e._v("解决办法有三种，第一种是使用闭包的方式")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("for (var i = 1; i <= 5; i++) {\n  ;(function(j) {\n    setTimeout(function timer() {\n      console.log(j)\n    }, j * 1000)\n  })(i)\n}\n")])])]),t("p",[e._v("在上述代码中，我们首先使用了立即执行函数将 "),t("code",[e._v("i")]),e._v(" 传入函数内部，这个时候值就被固定在了参数 "),t("code",[e._v("j")]),e._v(" 上面不会改变，当下次执行 "),t("code",[e._v("timer")]),e._v(" 这个闭包的时候，就可以使用外部函数的变量 "),t("code",[e._v("j")]),e._v("，从而达到目的。")]),e._v(" "),t("p",[e._v("第二种就是使用 "),t("code",[e._v("setTimeout")]),e._v(" 的第三个参数，这个参数会被当成 "),t("code",[e._v("timer")]),e._v(" 函数的参数传入。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("for (var i = 1; i <= 5; i++) {\n  setTimeout(\n    function timer(j) {\n      console.log(j)\n    },\n    i * 1000,\n    i\n  )\n}\n")])])]),t("p",[e._v("第三种就是使用 "),t("code",[e._v("let")]),e._v(" 定义 "),t("code",[e._v("i")]),e._v(" 了来解决问题了，这个也是最为推荐的方式")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("for (let i = 1; i <= 5; i++) {\n  setTimeout(function timer() {\n    console.log(i)\n  }, i * 1000)\n}\n")])])]),t("h2",{attrs:{id:"深浅拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深浅拷贝","aria-hidden":"true"}},[e._v("#")]),e._v(" 深浅拷贝")]),e._v(" "),t("p",[e._v("我们之前了解了对象类型在赋值的过程中其实是复制了地址，从而会导致改变了一方其他也都被改变的情况。通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个情况。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let a = {\n  age: 1\n}\nlet b = a\na.age = 2\nconsole.log(b.age) // 2\n")])])]),t("h3",{attrs:{id:"浅拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝","aria-hidden":"true"}},[e._v("#")]),e._v(" 浅拷贝")]),e._v(" "),t("p",[e._v("首先可以通过 "),t("code",[e._v("Object.assign")]),e._v(" 来解决这个问题，很多人认为这个函数是用来深拷贝的。其实并不是，"),t("code",[e._v("Object.assign")]),e._v("只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let a = {\n  age: 1\n}\nlet b = Object.assign({}, a)\na.age = 2\nconsole.log(b.age) // 1\n")])])]),t("p",[e._v("另外我们还可以通过展开运算符 "),t("code",[e._v("...")]),e._v(" 来实现浅拷贝")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let a = {\n  age: 1\n}\nlet b = { ...a }\na.age = 2\nconsole.log(b.age) // 1\n")])])]),t("p",[e._v("通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用到深拷贝了")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let a = {\n  age: 1,\n  jobs: {\n    first: ‘FE’\n  }\n}\nlet b = { ...a }\na.jobs.first = ‘native’\nconsole.log(b.jobs.first) // native\n")])])]),t("p",[e._v("浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。")]),e._v(" "),t("h3",{attrs:{id:"深拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝","aria-hidden":"true"}},[e._v("#")]),e._v(" 深拷贝")]),e._v(" "),t("p",[e._v("这个问题通常可以通过 "),t("code",[e._v("JSON.parse(JSON.stringify(object))")]),e._v(" 来解决。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let a = {\n  age: 1,\n  jobs: {\n    first: ‘FE’\n  }\n}\nlet b = JSON.parse(JSON.stringify(a))\na.jobs.first = ‘native’\nconsole.log(b.jobs.first) // FE\n")])])]),t("p",[e._v("但是该方法也是有局限性的：")]),e._v(" "),t("ul",[t("li",[e._v("会忽略 undefined")]),e._v(" "),t("li",[e._v("会忽略 symbol")]),e._v(" "),t("li",[e._v("不能序列化函数")]),e._v(" "),t("li",[e._v("不能解决循环引用的对象")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let obj = {\n  a: 1,\n  b: {\n    c: 2,\n    d: 3,\n  },\n}\nobj.c = obj.b\nobj.e = obj.a\nobj.b.c = obj.c\nobj.b.d = obj.b\nobj.b.e = obj.b.c\nlet newObj = JSON.parse(JSON.stringify(obj))\nconsole.log(newObj)\n")])])]),t("p",[e._v("如果你有这么一个循环引用对象，你会发现并不能通过该方法实现深拷贝")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://imgs.webxiaofan.com/15467596557702.jpg",alt:""}})]),e._v(" "),t("p",[e._v("在遇到函数、 "),t("code",[e._v("undefined")]),e._v(" 或者 "),t("code",[e._v("symbol")]),e._v(" 的时候，该对象也不能正常的序列化")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let a = {\n  age: undefined,\n  sex: Symbol(‘male’),\n  jobs: function() {},\n  name: ‘yck’\n}\nlet b = JSON.parse(JSON.stringify(a))\nconsole.log(b) // {name: “yck”}\n")])])]),t("p",[e._v("你会发现在上述情况中，该方法会忽略掉函数和 "),t("code",[e._v("undefined")]),e._v(" 。")]),e._v(" "),t("p",[e._v("但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题。")]),e._v(" "),t("p",[e._v("如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 "),t("code",[e._v("MessageChannel")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function structuralClone(obj) {\n  return new Promise(resolve => {\n    const { port1, port2 } = new MessageChannel()\n    port2.onmessage = ev => resolve(ev.data)\n    port1.postMessage(obj)\n  })\n}\n\nvar obj = {\n  a: 1,\n  b: {\n    c: 2\n  }\n}\n\nobj.b.d = obj.b\n\n// 注意该方法是异步的\n// 可以处理 undefined 和循环引用对象\nconst test = async () => {\n  const clone = await structuralClone(obj)\n  console.log(clone)\n}\ntest()\n")])])]),t("p",[e._v("当然你可能想自己来实现一个深拷贝，但是其实实现一个深拷贝是很困难的，需要我们考虑好多种边界情况，比如原型链如何处理、"),t("code",[e._v("DOM")]),e._v(" 如何处理等等，所以这里我们实现的深拷贝只是简易版，并且我其实更推荐使用 "),t("code",[e._v("lodash")]),e._v(" 的深拷贝函数。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function deepClone(obj) {\n  function isObject(o) {\n    return (typeof o === ‘object’ || typeof o === ‘function’) && o !== null\n  }\n\n  if (!isObject(obj)) {\n    throw new Error(‘非对象’)\n  }\n\n  let isArray = Array.isArray(obj)\n  let newObj = isArray ? [...obj] : { ...obj }\n  Reflect.ownKeys(newObj).forEach(key => {\n    newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]\n  })\n\n  return newObj\n}\n\nlet obj = {\n  a: [1, 2, 3],\n  b: {\n    c: 2,\n    d: 3\n  }\n}\nlet newObj = deepClone(obj)\nnewObj.b.c = 1\nconsole.log(obj.b.c) // 2\n")])])]),t("h2",{attrs:{id:"原型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型","aria-hidden":"true"}},[e._v("#")]),e._v(" 原型")]),e._v(" "),t("p",[e._v("当我们创建一个对象时 "),t("code",[e._v("let obj = { age: 28 }")]),e._v("，我们可以发现能使用很多种函数，但是我们明明没有定义过它们，对于这种情况你是否有过疑惑？")]),e._v(" "),t("p",[e._v("当我们在浏览器中打印 "),t("code",[e._v("obj")]),e._v(" 时你会发现，在 "),t("code",[e._v("obj")]),e._v(" 上居然还有一个 "),t("code",[e._v("__proto__")]),e._v(" 属性，那么看来之前的疑问就和这个属性有关系了。")]),e._v(" "),t("p",[e._v("其实每个 "),t("code",[e._v("JS")]),e._v(" 对象都有 "),t("code",[e._v("__proto__")]),e._v(" 属性，这个属性指向了原型。这个属性在现在来说已经不推荐直接去使用它了，这只是浏览器在早期为了让我们访问到内部属性 "),t("code",[e._v("[[prototype]]")]),e._v(" 来实现的一个东西。")]),e._v(" "),t("p",[e._v("讲到这里好像还是没有弄明白什么是原型，接下来让我们再看看 "),t("code",[e._v("__proto__")]),e._v(" 里面有什么吧。")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://imgs.webxiaofan.com/15467598786701.jpg",alt:""}})]),e._v(" "),t("p",[e._v("看到这里你应该明白了，原型也是一个对象，并且这个对象中包含了很多函数，所以我们可以得出一个结论：")]),e._v(" "),t("blockquote",[t("p",[e._v("对于 "),t("code",[e._v("obj")]),e._v(" 来说，可以通过 "),t("code",[e._v("__proto__")]),e._v(" 找到一个原型对象，在该对象中定义了很多函数让我们来使用。")])]),e._v(" "),t("p",[e._v("在上面的图中我们还可以发现一个 "),t("code",[e._v("constructor")]),e._v(" 属性，也就是构造函数")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://imgs.webxiaofan.com/15467599943517.jpg",alt:""}})]),e._v(" "),t("p",[e._v("打开 "),t("code",[e._v("constructor")]),e._v(" 属性我们又可以发现其中还有一个 "),t("code",[e._v("prototype")]),e._v(" 属性，并且这个属性对应的值和先前我们在 "),t("code",[e._v("__proto__")]),e._v(" 中看到的一模一样。所以我们又可以得出一个结论：")]),e._v(" "),t("blockquote",[t("p",[e._v("原型的 "),t("code",[e._v("constructor")]),e._v(" 属性指向构造函数，构造函数又通过 "),t("code",[e._v("prototype")]),e._v(" 属性指回原型，但是并不是所有函数都具有这个属性，"),t("code",[e._v("Function.prototype.bind()")]),e._v(" 就没有这个属性。")])]),e._v(" "),t("p",[e._v("接下来我们再来看一张图，来帮助我们更好的理解原型和原型链")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://imgs.webxiaofan.com/15467601230948.jpg",alt:""}})]),e._v(" "),t("p",[e._v("看完这张图，我再来解释下什么是原型链吧。其实原型链就是多个对象通过 "),t("code",[e._v("__proto__")]),e._v(" 的方式连接了起来。为什么 "),t("code",[e._v("obj")]),e._v(" 可以访问到 "),t("code",[e._v("valueOf")]),e._v(" 函数，就是因为 "),t("code",[e._v("obj")]),e._v(" 通过原型链找到了 "),t("code",[e._v("valueOf")]),e._v(" 函数。")]),e._v(" "),t("p",[e._v("总结起来就是以下几点：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("Object")]),e._v(" 是所有对象的爸爸，所有对象都可以通过 "),t("code",[e._v("__proto__")]),e._v(" 找到它")]),e._v(" "),t("li",[t("code",[e._v("Function")]),e._v(" 是所有函数的爸爸，所有函数都可以通过 "),t("code",[e._v("__proto__")]),e._v(" 找到它")]),e._v(" "),t("li",[e._v("函数的 "),t("code",[e._v("prototype")]),e._v(" 是一个对象")]),e._v(" "),t("li",[e._v("对象的 "),t("code",[e._v("__proto__")]),e._v(" 属性指向原型， "),t("code",[e._v("__proto__")]),e._v(" 将对象和原型连接起来组成了原型链")])])])}],!1,null,null,null);v.default=a.exports}}]);