(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{173:function(e,a,t){"use strict";t.r(a);var n=t(0),s=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"js异步相关"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js异步相关","aria-hidden":"true"}},[e._v("#")]),e._v(" JS异步相关")]),e._v(" "),t("h2",{attrs:{id:"并发（concurrency）和并行（parallelism）区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并发（concurrency）和并行（parallelism）区别","aria-hidden":"true"}},[e._v("#")]),e._v(" 并发（concurrency）和并行（parallelism）区别")]),e._v(" "),t("p",[e._v("并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。")]),e._v(" "),t("p",[e._v("并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。")]),e._v(" "),t("h2",{attrs:{id:"回调函数（callback）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回调函数（callback）","aria-hidden":"true"}},[e._v("#")]),e._v(" 回调函数（Callback）")]),e._v(" "),t("p",[e._v("回调函数应该是大家经常使用到的，以下代码就是一个回调函数的例子：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("ajax(url, () => {\n    // 处理逻辑\n})\n")])])]),t("p",[e._v("但是回调函数有一个致命的弱点，就是容易写出回调地狱"),t("code",[e._v("（Callback hell）")]),e._v("。假设多个请求存在依赖性，你可能就会写出如下代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("ajax(url, () => {\n    // 处理逻辑\n    ajax(url1, () => {\n        // 处理逻辑\n        ajax(url2, () => {\n            // 处理逻辑\n        })\n    })\n})\n")])])]),t("p",[e._v("以上代码看起来不利于阅读和维护，当然，你可能会想说解决这个问题还不简单，把函数分开来写不就得了")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function firstAjax() {\n  ajax(url1, () => {\n    // 处理逻辑\n    secondAjax()\n  })\n}\nfunction secondAjax() {\n  ajax(url2, () => {\n    // 处理逻辑\n  })\n}\najax(url, () => {\n  // 处理逻辑\n  firstAjax()\n})\n")])])]),t("p",[e._v("以上的代码虽然看上去利于阅读了，但是还是没有解决根本问题。")]),e._v(" "),t("p",[e._v("回调地狱的根本问题就是：")]),e._v(" "),t("ul",[t("li",[e._v("嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身")]),e._v(" "),t("li",[e._v("嵌套函数一多，就很难处理错误")])]),e._v(" "),t("p",[e._v("当然，回调函数还存在着别的几个缺点，比如不能使用 "),t("code",[e._v("try catch")]),e._v(" 捕获错误，不能直接 "),t("code",[e._v("return")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"generator"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generator","aria-hidden":"true"}},[e._v("#")]),e._v(" Generator")]),e._v(" "),t("p",[t("code",[e._v("Generator")]),e._v(" 算是 "),t("code",[e._v("ES6")]),e._v(" 中难理解的概念之一了，"),t("code",[e._v("Generator")]),e._v(" 最大的特点就是可以控制函数的执行。在这一小节中我们不会去讲什么是 "),t("code",[e._v("Generator")]),e._v("，而是把重点放在 "),t("code",[e._v("Generator")]),e._v(" 的一些容易困惑的地方。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function *foo(x) {\n  let y = 2 * (yield (x + 1))\n  let z = yield (y / 3)\n  return (x + y + z)\n}\nlet it = foo(5)\nconsole.log(it.next())   // => {value: 6, done: false}\nconsole.log(it.next(12)) // => {value: 8, done: false}\nconsole.log(it.next(13)) // => {value: 42, done: true}\n\n")])])]),t("p",[e._v("你也许会疑惑为什么会产生与你预想不同的值，接下来就让我为你逐行代码分析原因")]),e._v(" "),t("ul",[t("li",[e._v("首先 Generator 函数调用和普通函数不同，它会返回一个迭代器")]),e._v(" "),t("li",[e._v("当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6")]),e._v(" "),t("li",[e._v("当执行第二次 next 时，传入的参数等于上一个 yield 的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8")]),e._v(" "),t("li",[e._v("当执行第三次 next 时，传入的参数会传递给 z，所以 z = 13, x = 5, y = 24，相加等于 42")])]),e._v(" "),t("p",[t("code",[e._v("Generator")]),e._v(" 函数一般见到的不多，其实也于他有点绕有关系，并且一般会配合 "),t("code",[e._v("co")]),e._v(" 库去使用。当然，我们可以通过 "),t("code",[e._v("Generator")]),e._v(" 函数解决回调地狱的问题，可以把之前的回调地狱例子改写为如下代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function *fetch() {\n    yield ajax(url, () => {})\n    yield ajax(url1, () => {})\n    yield ajax(url2, () => {})\n}\nlet it = fetch()\nlet result1 = it.next()\nlet result2 = it.next()\nlet result3 = it.next()\n")])])]),t("h2",{attrs:{id:"promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise","aria-hidden":"true"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),t("p",[t("code",[e._v("Promise")]),e._v(" 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态，分别是：")]),e._v(" "),t("ul",[t("li",[e._v("等待中（pending）")]),e._v(" "),t("li",[e._v("完成了 （resolved）")]),e._v(" "),t("li",[e._v("拒绝了（rejected）")])]),e._v(" "),t("p",[e._v("这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 "),t("code",[e._v("resolved")]),e._v(" 后，就不能再次改变")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("new Promise((resolve, reject) => {\n  resolve('success')\n  // 无效\n  reject('reject')\n})\n")])])]),t("p",[e._v("当我们在构造 "),t("code",[e._v("Promise")]),e._v(" 的时候，构造函数内部的代码是立即执行的")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("new Promise((resolve, reject) => {\n  console.log('new Promise')\n  resolve('success')\n})\nconsole.log('finifsh')\n// new Promise -> finifsh\n")])])]),t("p",[t("code",[e._v("Promise")]),e._v(" 实现了链式调用，也就是说每次调用 "),t("code",[e._v("then")]),e._v(" 之后返回的都是一个 "),t("code",[e._v("Promise")]),e._v("，并且是一个全新的 "),t("code",[e._v("Promise")]),e._v("，原因也是因为状态不可变。如果你在 "),t("code",[e._v("then")]),e._v(" 中 使用了 "),t("code",[e._v("return")]),e._v("，那么 "),t("code",[e._v("return")]),e._v(" 的值会被 "),t("code",[e._v("Promise.resolve()")]),e._v(" 包装")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Promise.resolve(1)\n  .then(res => {\n    console.log(res) // => 1\n    return 2 // 包装成 Promise.resolve(2)\n  })\n  .then(res => {\n    console.log(res) // => 2\n  })\n")])])]),t("p",[e._v("当然了，Promise 也很好地解决了回调地狱的问题，可以把之前的回调地狱例子改写为如下代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("ajax(url)\n  .then(res => {\n      console.log(res)\n      return ajax(url1)\n  }).then(res => {\n      console.log(res)\n      return ajax(url2)\n  }).then(res => console.log(res))\n")])])]),t("p",[e._v("前面都是在讲述 "),t("code",[e._v("Promise")]),e._v(" 的一些优点和特点，其实它也是存在一些缺点的，比如无法取消 "),t("code",[e._v("Promise")]),e._v("，错误需要通过回调函数捕获。")]),e._v(" "),t("h2",{attrs:{id:"async-及-await"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async-及-await","aria-hidden":"true"}},[e._v("#")]),e._v(" async 及 await")]),e._v(" "),t("p",[e._v("一个函数如果加上 "),t("code",[e._v("async")]),e._v(" ，那么该函数就会返回一个 "),t("code",[e._v("Promise")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('async function test() {\n  return "1"\n}\nconsole.log(test()) // -> Promise {<resolved>: "1"}\n')])])]),t("p",[t("code",[e._v("async")]),e._v(" 就是将函数返回值使用 "),t("code",[e._v("Promise.resolve()")]),e._v(" 包裹了下，和 "),t("code",[e._v("then")]),e._v(" 中处理返回值一样，并且 "),t("code",[e._v("await")]),e._v(" 只能配套 "),t("code",[e._v("async")]),e._v(" 使用")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("async function test() {\n  let value = await sleep()\n}\n")])])]),t("p",[t("code",[e._v("async")]),e._v(" 和 "),t("code",[e._v("await")]),e._v(" 可以说是异步终极解决方案了，相比直接使用 "),t("code",[e._v("Promise")]),e._v(" 来说，优势在于处理 "),t("code",[e._v("then")]),e._v(" 的调用链，能够更清晰准确的写出代码，毕竟写一大堆 "),t("code",[e._v("then")]),e._v(" 也很恶心，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 "),t("code",[e._v("await")]),e._v(" 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 "),t("code",[e._v("await")]),e._v(" 会导致性能上的降低。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("async function test() {\n  // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式\n  // 如果有依赖性的话，其实就是解决回调地狱的例子了\n  await fetch(url)\n  await fetch(url1)\n  await fetch(url2)\n}\n")])])]),t("p",[e._v("下面来看一个使用 "),t("code",[e._v("await")]),e._v(" 的例子：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let a = 0\nlet b = async () => {\n  a = a + await 10\n  console.log('2', a) // -> '2' 10\n}\nb()\na++\nconsole.log('1', a) // -> '1' 1\n")])])]),t("p",[e._v("对于以上代码你可能会有疑惑，让我来解释下原因")]),e._v(" "),t("ul",[t("li",[e._v("首先函数 "),t("code",[e._v("b")]),e._v(" 先执行，在执行到 "),t("code",[e._v("await 10")]),e._v(" 之前变量 "),t("code",[e._v("a")]),e._v(" 还是 "),t("code",[e._v("0")]),e._v("，因为 "),t("code",[e._v("await")]),e._v(" 内部实现了 "),t("code",[e._v("generator")]),e._v(" ，"),t("code",[e._v("generator")]),e._v(" 会保留堆栈中东西，所以这时候 "),t("code",[e._v("a = 0")]),e._v(" 被保存了下来")]),e._v(" "),t("li",[e._v("因为 await 是异步操作，后来的表达式不返回 "),t("code",[e._v("Promise")]),e._v(" 的话，就会包装成 "),t("code",[e._v("Promise.reslove(返回值)")]),e._v("，然后会去执行函数外的同步代码")]),e._v(" "),t("li",[e._v("同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 "),t("code",[e._v("a = 0 + 10")]),e._v("\n上述解释中提到了 "),t("code",[e._v("await")]),e._v(" 内部实现了 "),t("code",[e._v("generator")]),e._v("，其实 "),t("code",[e._v("await")]),e._v(" 就是 "),t("code",[e._v("generator")]),e._v(" 加上 "),t("code",[e._v("Promise")]),e._v(" 的语法糖，且内部实现了自动执行 "),t("code",[e._v("generator")]),e._v("。如果你熟悉 "),t("code",[e._v("co")]),e._v(" 的话，其实自己就可以实现这样的语法糖。")])])])}],!1,null,null,null);a.default=s.exports}}]);